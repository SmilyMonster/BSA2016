# BSA2016
1. Работа с историей изменений. Написать команды:
1.1. которая выводит сообщения и автора всех коммитов из ветки develop-feature1, которые сделаны за последние 3 часа и которых нет в родительских ветках (develop, master). Сортировка по дате, первые более новые.

Ответ:
git log --walk-reflogs develop-feature1 --pretty=format:"%an - %s" --since=3.hours
 
По умолчанию (без аргументов) git log перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке – последние коммиты находятся вверху.
Значение переменной gc.reflogExpire хранит информацию 90, но в связи с тем, что наш промежуток 3 часа, история записей в пределах reflog каждой ветви остается доступным в хранилище на нужный нам промежуток времени.
--pretty=format: — параметр, который позволяет полностью создать собственный формат вывода лога.
"%an - %s" — имя автора и комментари.
--since=3.hours — параметр, ограничивающий по времени.

1.2. выводит для каждого коммита из веток master, develop, в сообщении которых есть упоминание заданного номера задачи (допустим задачи 231), его сообщение, автора и дату. Сортировка по дате, первые более новые.

Ответ:
git log master develop --pretty=format:" %an - %s %ad " --grep=231

где %ad — дата автора (формат соответствует параметру --date=).
опция --grep позволяет искать по ключевым словам в сообщении.     

2. “Избирательное слияние”. 
Дано: После слияния ветки develop-feature1 в develop, вы продолжили работать в ветке develop-feature1, а develop отдали на тестирование, потом исправили ошибку и закоммитили исправление в develop-feature1, сделали push. Через какое-то время тим лид говорит, что это критический фикс, и надо включить его в develop. Вы делаете pull в ветке develop-feature1 и оказывается, что ваш коллега сделал еще 3 коммита после вашего, и они не стабильные, поэтому не должны быть включены в develop. 
Задание: как добавить в develop только ваш коммит, но чтобы 3 коммита после него в develop не попали?

Ответ:
git checkout develop — переключаемся на ветку develop.
git cherry-pick commit SHA1 — git cherry-pick помогает применить коммит из одной ветки к дереву другой, commit SHA1  — код коммита, который добавляем в ветку develop.
git push — пушим commit.

3. “Исправление ошибок”.
Дано: Вы начали работу над новой фичей и создали от develop дочернюю ветку develop-feature3. Сделали там несколько коммитов, и синхронизировались с сервером - все ваши изменения теперь в develop-feature3 на сервере. И тут вы вспомнили, что тим лид строго настрого сказал, что сообщение каждого коммита должно быть форматировано определенным образом (см. примечание п.0) и обязательно содержать номер задачи. А вы об этом забыли и теперь на сервере лежит ветка develop-feature1 3??с “плохими” сообщениями. 
Задание: Предложите вариант, как наиболее просто исправить ситуацию, чтобы тим лид не увидел ваш промах.

Ответ: 
git log --oneline --graph --all --decorate
1. Определелись, что будем фиксить: здесь, oneline выводит каждый коммит в одну строку, --graph показывает историю ветвлений и слияний, --decorate показывает ссылки на коммит.
git rebase -i HEAD~n 
2. Команда rebase берет все изменения, попавшие в коммиты на одной из веток, и повторяет их на другой. Опция -i, добавленная к git rebase, запускает интерактивное перемещение, а HEAD~n — аргумент родителя последнего коммита, который мы хотим изменить
3. Меняем у нужных коммитов ‘pick’ на ‘r’ или ‘reword’, затем поочерёдно правим каждое сообщение.
git log --oneline --graph  --decorate --all
4. Проверяем обновление сообщений. 
git push origin develop-feature3--force-with-lease 
5. git push — запилиаваем изменения на сервер, --force-with-lease использовать предпочтительней, так как защищает от “затирания” чужих изменений.




